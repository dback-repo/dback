cliRequest := cli.ParseCLI()
//cliRequest.VerifyAndSetDefaults()

dockerWrapper := NewDockerWrapper(NewDockerClient())
defer dockerWraper.Close()

//dockerWrapper.CheckWeAreInDocker()


f := cliRequest.Flags
switch cliRequest.Command {
case `backup`:
	resticWrapper := NewResticWrapper(endpoint, bucket, accKey, secKey, resticPassword)
	timestamp := NewTimestamp()
	logic.Backup(dockerWrapper, f[`emulate`], f[`x`], timestamp, resticWrapper, f[`t`])
case `restore`:
	logic.Restore(dockerWrapper, f[`emulate`])
case ``: //no command provided. Parse CLI is already printed an advice
	os.Exit(1)
default:
	log.Fatalln(`Unrecognized command ` + cliRequest.Command +
		`. Run with --help, for list of available commands`)
}



backup(dockerWrapper, isEmulation, excludePatterns, timestamp, resticWrapper, threadsCount){
	//stoppedContainers:=[]containers{}
	//defer(){   // for restore containers state, even after panic
	//	dockerWrapper.startContainers(*(&stoppedContainers))
	//}

	containersForBackup, mounts := dockerWrapper.getContanersAndMountsForBackup(excludePatterns)

	if isEmulation==`true` {
		printEmulateMessage(mounts)
		return
	}
	runningContainersForBackup := containersForBackup
	//runningContainersForBackup := dockerWrapper.SelectRunningContainers(containersForBackup)
	
	//Let's pretend containers are already stopped. 
	//It's ok: defer will try to start running containers in all cases. Nothing wrong is going to happen.
	//But if we set "stoppedContainers" after calling stop function - "stoppedContainers" could be empty 
	//due to panic in stopping function. Some containers will be stopped, but defer will not restore their state.	
	//stoppedContainers = runningContainersForBackup 
	dockerWrapper.StopContainers(runningContainersForBackup)

	//mountsTarSavedList := dockerWrapper.NewMountsTarSavedList()

	passOrExit(processArrayConcurrent(mounts, fn()error{
		backupMount(mount, dockerWrapper,  timestamp, resticWrapper) //, mountsTarSavedList, stoppedContainers)
	}, parseThreadsCount(threadsCount)))
	
	log.println(`backup done for mounts above.`)
}



backupMount(mount, dockerWrapper, mountsTarSavedList, stoppedContainers, timestamp, resticWrapper){
	mountTar := dockerWrapper.SaveMountAsTar(mount)
	//mountsTarSavedList.Add(mount)
	//if dockerWrapper.IsContainerFullyTarSaved(mount, mountsTarSavedList) && dockerWrapper.isContainerStoppedForBackup(container, stoppedContainers){
	//	dockerWrapper.startContainer(mount.ContainerID)
	//}
	mountFolder := dockerWrapper.UnpackArcihve(tar)
	//DeleteExcludesFromFolder(mountFolder)
	resticWrapper.UploadToS3(mountFolder)
	printMount()
}


func (t *DockerWrapper) getContanersAndMountsForBackup(excludePatterns)([]containers, []mounts){
	allContainers := t.getAllContainers()
	containersForBackup := allContainers
	//containersForBackup := dockerWrapper.ExcludeContaiers(allContainers, excludePatterns) //with cause in log

	mounts := dockerWrapper.GetMountsOfContainers(containersForBackup)
	//mounts := dockerWrapper.ExcludeMounts(mounts, excludePatterns) //with cause in log
	return containers, mounts
}